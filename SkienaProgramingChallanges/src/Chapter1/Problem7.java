package Chapter1;

import java.util.Scanner;



/*
 1.6.7 Check the Check
PC/UVa IDs: 110107/10196, Popularity: B, Success rate: average Level: 1
Your task is to write a program that reads a chess board configuration and identifies
whether a king is under attack (in check). A king is in check if it is on square which
can be taken by the opponent on his next move.
White pieces will be represented by upper case letters, and black pieces by lower case
letters. The white side will always be on the bottom of the board, with the black side
always on the top.
For those unfamiliar with chess, here are the movements of each piece:
Pawn (p or P): can only move straight ahead, one square at a time. However, it takes
pieces diagonally, and that is what concerns you in this problem.
Knight (n or N) : has an L-shaped movement shown below. It is the only piece that
can jump over other pieces.
Bishop (b or B) : can move any number of squares diagonally, either forward or
backward.
Rook (r or R) : can move any number of squares vertically or horizontally, either
forward or backward.
Queen (q or Q) : can move any number of squares in any direction (diagonally,
horizontally, or vertically) either forward or backward.
King (k or K) : can move one square at a time in any direction (diagonally,
horizontally, or vertically) either forward or backward.
Movement examples are shown below, where “*” indicates the positions where the
piece can capture another piece:
Pawn Rook Bishop Queen King Knight
........ ...*.... .......* ...*...* ........ ........
........ ...*.... *.....*. *..*..*. ........ ........
........ ...*.... .*...*.. .*.*.*.. ........ ..*.*...
........ ...*.... ..*.*... ..***... ..***... .*...*..
...p.... ***r**** ...b.... ***q**** ..*k*... ...n....
..*.*... ...*.... ..*.*... ..***... ..***... .*...*..
........ ...*.... .*...*.. .*.*.*.. ........ ..*.*...
........ ...*.... *.....*. *..*..*. ........ ........
Remember that the knight is the only piece that can jump over other pieces. The
pawn movement will depend on its side. If it is a black pawn, it can only move one
square diagonally down the board. If it is a white pawn, it can only move one square
diagonally up the board. The example above is a black pawn, described by a lower case
“p”. We use “move” to indicate the squares where the pawn can capture another piece.

Input
There will be an arbitrary number of board configurations in the input, each consisting
of eight lines of eight characters each. A “.” denotes an empty square, while upper-
and lower case letters represent the pieces as defined above. There will be no invalid
characters and no configurations where both kings are in check. You must read until you
find an empty board consisting only of “.” characters, which should not be processed.
There will be an empty line between each pair of board configurations. All boards,
except for the empty one, will contain exactly one white king and one black king.

Output
For each board configuration read you must output one of the following answers:
Game #d: white king is in check.
Game #d: black king is in check.
Game #d: no king is in check.
where d stands for the game number starting from 1.
Sample Input
..k.....
ppp.pppp
........
.R...B..
........
........
PPPPPPPP
K.......

rnbqk.nr
ppp..ppp
....p...
...p....
.bPP....
.....N..
PP..PPPP
RNBQKB.R

........
........
........
........
........
........
........
........
Sample Output
Game #1: black king is in check.
Game #2: white king is in check.
 */

/*
testing queen.
all outputs should be tru
........
Q......k
........
........
........
........
........
........

........
Q.....k.
........
........
........
........
........
........

........
Q....k..
........
........
........
........
........
........

........
Qk......
........
........
........
........
........
........

.......k
Q.......
........
........
........
........
........
........

.k......
Q.......
........
........
........
........
........
........

........
Q.......
........
k.......
........
........
........
........

........
Q.......
k.......
........
........
........
........
........

........
........
........
........
...Q....
....q...
.....k..
........

........
........
........
........
...N....
........
....k...
........

........
........
........
........
...N....
........
....k...
........

........
...k....
..k.....
........
....n...
......q.
...k....
........



........
........
..k.k...
.k...k..
...N....
.k...k..
..k.k...
........

........
........
..k.k...
.k...k..
...N....
.k...k..
..k.k...
........

........
........
..k.k...
.k...k..
...N....
.k...k..
..k.k...
........

........
........
..k.k...
.k...k..
...N....
.k...k..
..k.k...
........

........
........
..k.k...
.k...k..
...N....
.k...k..
..k.k...
........

........
........
..k.k...
.k...k..
...N....
.k...k..
..k.k...
........

........
........
..k.k...
.k...k..
...N....
.k...k..
..k.k...
........

........
........
........
........
...N....
........
....k...
........

......k.
........
........
........
...P....
........
........
........

......k.
........
........
....k...
...P....
........
........
........

......k.
........
........
........
...P....
....k...
........
........

......k.
........
........
........
...p....
....K...
........
........

......k.
........
........
........
...p....
........
...K....
........



 */

public class Problem7 {
	static int counter;
	public static void print( int matrix[][] ) {
		
		for ( int i  = 0 ; i < matrix.length ; ++i ) {
			for ( int j = 0 ; j < matrix[0].length ; ++j ) {
				System.out.print(matrix[i][j]+"  ");
			}
			System.out.println();
		}
	
	}
	
	
	public static void print( String a[] ) {
		for ( int i  = 0 ; i< a.length ; ++i ) 
			System.out.println(a[i]);
	}
	/*
	 public static void main ( String args[] ) {
		// test();
		 counter = 0;
		 Scanner in = new Scanner(System.in);
		 boolean flag = true;
		 while ( flag ) {
			 if ( counter > 0 ) in.nextLine();
			 ++counter;
			 flag = false;
			 String a[] = new String[8];
			 for ( int i = 0 ; i < 8 ; i++ ) {
				 a[i] = in.nextLine();
				 if ( ! a[i].equalsIgnoreCase("........") ) flag = true;
			 }
			 if ( flag ) checkCheck(a);
		 }
	 }
	*/
	
	 public static boolean checkCheck ( String[] board ) {
	        int[][] field = new int[board.length+4][board.length+4];
	        for ( int i = 0 ; i < board.length+4 ; i++ ) {
	            field[i][0] = 1;
	            field[i][1] = 1;
	            field[i][board.length+2] = 1;
	            field[i][board.length+3] = 1;
	            field[0][i] = 1;
	            field[1][i] = 1;
	            field[board.length+2][i] = 1;
	            field[board.length+3][i] = 1;
	        }
	        for ( int i = 2 ; i < board.length+2 ; i++ ) {
	            for ( int j = 2 ; j < board.length+2 ; j++ ) {
	                field[i][j] = board[i-2].charAt(j-2)-'.';
	            }
	        }
	        //print(field);
	        boolean black_king_under_check = false;
	        boolean white_king_under_check = false;
	        for ( int i = 0 ; i < board.length ; i++ ) {
	            for ( int j = 0 ; j < board.length ; j++ ) {
	                if ( board[i].charAt(j) == 'K' ) {
	                    
	                }
	                if ( board[i].charAt(j) == 'R' ) {
	                	if ( checkRook(field, i+2, j+2,'k'-'.') ) black_king_under_check = true;
	                }
	                if ( board[i].charAt(j) == 'N' ) {
	                	if ( checkKnight(field, i+2, j+2,'k'-'.') ) black_king_under_check = true;
	                }
	                if ( board[i].charAt(j) == 'B' ) {
	                	if ( checkBishop(field, i+2, j+2,'k'-'.') ) black_king_under_check = true;
	                }
	                if ( board[i].charAt(j) == 'Q' ) {
	                	if ( checkQueen(field, i+2, j+2 , 'k'-'.' ) ) black_king_under_check = true;
	                }
	                if ( board[i].charAt(j) == 'P' ) {
	                	if ( checkPeon(field, i+2, j+2 ,'k'-'.',1) ) black_king_under_check = true;//1 - dirrection up
	                }
	                
	                if ( board[i].charAt(j) == 'r' ) {
	                	if ( checkRook(field, i+2, j+2,'K'-'.') ) white_king_under_check = true;
	                }
	                if ( board[i].charAt(j) == 'n' ) {
	                	if ( checkKnight(field, i+2, j+2,'K'-'.') ) white_king_under_check = true;
	                }
	                if ( board[i].charAt(j) == 'b' ) {
	                	if ( checkBishop(field, i+2, j+2,'K'-'.') ) white_king_under_check = true;
	                }
	                if ( board[i].charAt(j) == 'q' ) {
	                	if ( checkQueen(field, i+2, j+2 , 'K'-'.' ) ) white_king_under_check = true;
	                }
	                if ( board[i].charAt(j) == 'p' ) {
	                	if ( checkPeon(field, i+2, j+2 ,'K'-'.',0) ) white_king_under_check = true;//1 - direction up
	                }
	            }
	        }
	       // System.out.println();
	        if ( black_king_under_check ) {
	        	System.out.println("Game #"+counter+": black king is in check.");
	        }
	        if ( white_king_under_check ) {
	        	System.out.println("Game #"+counter+": white king is in check.");
	        }
	        if ( !black_king_under_check && !white_king_under_check ) {
	        	System.out.println("Game #"+counter+": no king is in check.");
	        }
	        //System.out.println();
	        return true;
	        
	    }

	    public static boolean checkRook ( int[][] board , int x , int y , int target ) {
	    	int i = x;
	    	int j = y-1;
	    	while ( board[i][j] == 0 ) {
	    		//i--;
	    		j--;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x;
	    	j = y+1;
	    	while ( board[i][j] == 0 ) {
	    		//i--;
	    		j++;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x+1;
	    	j = y;
	    	while ( board[i][j] == 0 ) {
	    		i++;
	    		//j--;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x-1;
	    	j = y;
	    	while ( board[i][j] == 0 ) {
	    		i--;
	    		//j++;
	    	}
	    	if ( board[i][j] == target ) return true;
	        return false;
	    }

	    public static boolean checkKnight (int[][] board , int x , int y , int target ) {
	    	int dx[] = { 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 };
	    	int dy[] = { -2 , -1 , 1 , 2 , 2 , 1 , -1 , -2 };
	    	for ( int i = 0 ; i < dx.length ; ++i ) {
	    		if ( board[x+dx[i]][y+dy[i]] == target ) return true;
	    	}
	        return false;
	    }

	    public static boolean checkPeon ( int[][] board , int x , int y , int target , int dirrection  ) {
	    	if ( dirrection == 1 ) {
	    		if ( board[x-1][y-1] == target || board[x-1][y+1] == target )
	    			return true;
	    	}
	    	if ( dirrection == 0 ) {
	    		if ( board[x+1][y-1] == target || board[x+1][y+1] == target )
	    			return true;
	    	}
	        return false;
	    }

	    public static boolean checkBishop ( int[][] board , int x , int y , int target ) {
	    	int i = x-1;
	    	int j = y-1;
	    	while ( board[i][j] == 0 ) {
	    		i--;
	    		j--;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x-1;
	    	j = y+1;
	    	while ( board[i][j] == 0 ) {
	    		i--;
	    		j++;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x+1;
	    	j = y-1;
	    	while ( board[i][j] == 0 ) {
	    		i++;
	    		j--;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x+1;
	    	j = y+1;
	    	while ( board[i][j] == 0 ) {
	    		i++;
	    		j++;
	    	}
	    	if ( board[i][j] == target ) return true;
	        return false;
	    }

	    public static boolean checkQueen ( int[][] board , int x , int y , int target ) {
	    	int i = x;
	    	int j = y-1;
	    	while ( board[i][j] == 0 ) {
	    		//i--;
	    		j--;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x;
	    	j = y+1;
	    	while ( board[i][j] == 0 ) {
	    		//i--;
	    		j++;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x+1;
	    	j = y;
	    	while ( board[i][j] == 0 ) {
	    		i++;
	    		//j--;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x-1;
	    	j = y;
	    	while ( board[i][j] == 0 ) {
	    		i--;
	    		//j++;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	
	    	i = x-1;
	    	j = y-1;
	    	while ( board[i][j] == 0 ) {
	    		i--;
	    		j--;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x-1;
	    	j = y+1;
	    	while ( board[i][j] == 0 ) {
	    		i--;
	    		j++;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x+1;
	    	j = y-1;
	    	while ( board[i][j] == 0 ) {
	    		i++;
	    		j--;
	    	}
	    	if ( board[i][j] == target ) return true;
	    	i = x+1;
	    	j = y+1;
	    	while ( board[i][j] == 0 ) {
	    		i++;
	    		j++;
	    	}
	    	if ( board[i][j] == target ) return true;
	        return false;
	    }

	    public static boolean checkKing ( int[][] board , int x , int y , int target ) {

	        return true;
	    }

	    public static void test() {
	    	for ( int h = 0 ; h < 1000000 ; ++h ) {
		    	char board[][] = new char[8][8];
		    	for ( int i = 0 ; i < 8 ; ++i ) {
		    		for ( int j = 0 ; j < 8 ; ++j ) {
		    			int what = (int) (20*Math.random());
		    			if ( what == 0 ) {
		    				board[i][j] = 'K';
		    			}
		    			if ( what == 1 ) {
		    				board[i][j] = 'k';
		    			}
		    			if ( what == 2 ) {
		    				board[i][j] = 'Q';
		    			}
		    			if ( what == 3 ) {
		    				board[i][j] = 'q';
		    			}
		    			if ( what == 4 ) {
		    				board[i][j] = 'R';
		    			}
		    			if ( what == 5 ) {
		    				board[i][j] = 'r';
		    			}
		    			if ( what == 6 ) {
		    				board[i][j] = 'B';
		    			}
		    			if ( what == 7 ) {
		    				board[i][j] = 'b';
		    			}
		    			if ( what == 8 ) {
		    				board[i][j] = 'N';
		    			}
		    			if ( what == 9 ) {
		    				board[i][j] = 'n';
		    			}
		    			if ( what == 10 ) {
		    				board[i][j] = 'P';
		    			}
		    			if ( what == 1 ) {
		    				board[i][j] = 'p';
		    			}
		    		}
		    	
		    	}
		    	String board_string[] = new String[8];
		    	for ( int i = 0 ; i < 8 ; ++i ) board_string[i] = new String(board[i]);
		    	checkCheck(board_string);
	    	}
	    	
	    }
	    
}
 